/*
 * Salvatore Criscione 2013-2014
 * <not.salvatore@logorroici.org>
 *
 * Difensore NXC Soccer
 *
 */

// Motore destro
#define MOTOR_D OUT_B

// Motore sinistro
#define MOTOR_S OUT_C

// Motore barriera
#define MOTOR_A OUT_A



#define DAVANTI   1
#define DESTRA    2
#define SINISTRA  3
#define SPIN      4

#define AVANTI    1
#define INDIETRO  0


#define M_FAST    100
#define M_SLOW    50
#define M_INV     -100
/*
 * SENSOR_C     Sensore Bussola
 * SENSOR_L     Sensore Luce
 * SENSOR_I     Sensore Infrarossi
 *
 */

#define SENSOR_C  S3
#define SENSOR_L  S2
#define SENSOR_I  S1

int dir, vers, baseline,dd,  pot, cal, ownGoal, currentCompass, relBearing;

mutex moveMutex;

void HTEnhancedIRSeekerV2(const byte  port, int &dir, int &strength);
void move(int a, int b);
void println(string what, int num);

task nowSensor() {
  while (1) {
    baseline = Sensor(SENSOR_L);

    currentCompass=SensorHTCompass(SENSOR_C);

    HTEnhancedIRSeekerV2(SENSOR_I, dd, pot);

    if ( baseline < cal - 15 )
      vers = INDIETRO;
    else {
      if ( dd < 5 ) {
        println("Vado a sinistra", 0);
        dir = SINISTRA;
      }
      if ( dd > 5 ) {
        println("Vado a destra", 0);
        dir = DESTRA;
      }
      if ( dd == 5 ) {
        println("Vado avanti", 0);
        dir = DAVANTI;
      }
      Wait(100);
    }
  }
}

task moving() {
     while(1){
       switch(dir) {
         case DAVANTI:
           move(M_FAST, M_FAST);
           break;
         case DESTRA:
           move(M_FAST, M_SLOW);
           break;
         case SINISTRA:
           move(M_SLOW, M_FAST);
           break;
       }
     }
}

task main(){
   setSensorCompass();
   SetSensorLight(S2);
   cal = Sensor(S2);
   Precedes(moving,nowSensor);
}

void HTEnhancedIRSeekerV2(const byte  port, int &dir, int &strength) {
  int cResp;
  byte cmdBuf[] = {0x10, 0x43};   // Read DC signal strengths (skip the dir)
  byte respBuf[];                 // Response Buffer
  bool fSuccess;
  int i, iMax;
  long dcSigSum, dcStr;

  dir = 0;
  strength = 0;

  // Read DC mode
  cResp=6;
  fSuccess = I2CBytes(port, cmdBuf, cResp, respBuf);
  if (fSuccess) {
    // Find the max DC sig strength
    iMax = 0;
    for (i=1; i<5; i++) if (respBuf[i] > respBuf[iMax]) iMax = i;
    // Calc base DC direction value
    dir = iMax*2+1;
    // Set base dcStrength based on max signal and average
    dcSigSum = respBuf[iMax] + respBuf[5];
    // Check signal strength of neighboring sensor elements
    if ((iMax > 0) && (respBuf[iMax-1] > respBuf[iMax]/2)) {
        dir--;
        dcSigSum += respBuf[iMax-1];
    }
    if ((iMax < 4) && (respBuf[iMax+1] > respBuf[iMax]/2)) {
        dir++;
        dcSigSum += respBuf[iMax+1];
    }
    // Make DC strength compatible with AC strength. use: sqrt(dcSigSum*500)
    dcSigSum *= 500; dcStr = 1;
    repeat(10) dcStr = (dcSigSum/dcStr + dcStr) / 2;  // sqrt approx
    strength = dcStr;
    // Decide if using DC strength or should read and use AC strength
    if (strength <= 200) {
      // Use AC Dir
      dir = 0; strength = 0;
      cmdBuf[1] = 0x49; // Recycle rest of cmdBuf from the DC read operation
      cResp=6;
      fSuccess = I2CBytes(port, cmdBuf, cResp, respBuf);
      if (fSuccess) {
        dir = respBuf[0];
        // Sum the sensor elements to get strength
        if (dir > 0) for (i=1; i<=5; i++) strength += respBuf[i];
      }
    }
  }
}

void println(string what, int num){
     ClearScreen();
     TextOut(10,LCD_LINE5,what);
     NumOut(10,LCD_LINE6,num);
}

void move(int a, int b) {
     Acquire(moveMutex);
     if ( vers == 0 )
     if ( a != 0 )
        OnFwd(MOTOR_D, a);
     if ( b != 0 )
        OnFwd(MOTOR_S, b);
     Release(moveMutex);
}
