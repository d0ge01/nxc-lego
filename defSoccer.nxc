/*
 * Salvatore Criscione & Matteo Mazzon  2013-2014
 * <not.salvatore@logorroici.org>
 *
 * Difensore NXC Soccer
 *
 */

void HTEnhancedIRSeekerV2(const byte  port, int &dir, int &strength);
void turnRight();void turnLeft();void println(string what, int num);
int iSeeBlack(int GREEN);void goBackBlack();
int dir, int strength;

// Motore barriera
#define BARRIERA OUT_A

#define POWER 55
#define OVERPOWER 100


task main(){
   SetSensorLight(IN_2);
   SetSensorLowspeed(S1);
   int GREEN=Sensor(IN_2);
   PlayToneEx(012,100,2,FALSE);
   Wait(99);
   PlayToneEx(405,100,2,FALSE);
      while(true){
      HTEnhancedIRSeekerV2(S1,dir,strength);
      Off(OUT_ABC);
      OnFwd(BARRIERA,OVERPOWER);
      OnFwd(OUT_BC,POWER);
      println("DIR",dir);
      if (dir==7||dir==8||dir==9)
         turnRight();
      if (dir==3||dir==2||dir==1)
         turnLeft();
      if (iSeeBlack(GREEN)==0)
         goBackBlack();
      }
}

///////////////////////////////////////////////////////////////////////////////

void HTEnhancedIRSeekerV2(const byte  port, int &dir, int &strength) {
  int cResp;
  byte cmdBuf[] = {0x10, 0x43};   // Read DC signal strengths (skip the dir)
  byte respBuf[];                 // Response Buffer
  bool fSuccess;
  int i, iMax;
  long dcSigSum, dcStr;

  dir = 0;
  strength = 0;

  // Read DC mode
  cResp=6;
  fSuccess = I2CBytes(port, cmdBuf, cResp, respBuf);
  if (fSuccess) {
    // Find the max DC sig strength
    iMax = 0;
    for (i=1; i<5; i++) if (respBuf[i] > respBuf[iMax]) iMax = i;
    // Calc base DC direction value
    dir = iMax*2+1;
    // Set base dcStrength based on max signal and average
    dcSigSum = respBuf[iMax] + respBuf[5];
    // Check signal strength of neighboring sensor elements
    if ((iMax > 0) && (respBuf[iMax-1] > respBuf[iMax]/2)) {
        dir--;
        dcSigSum += respBuf[iMax-1];
    }
    if ((iMax < 4) && (respBuf[iMax+1] > respBuf[iMax]/2)) {
        dir++;
        dcSigSum += respBuf[iMax+1];
    }
    // Make DC strength compatible with AC strength. use: sqrt(dcSigSum*500)
    dcSigSum *= 500; dcStr = 1;
    repeat(10) dcStr = (dcSigSum/dcStr + dcStr) / 2;  // sqrt approx
    strength = dcStr;
    // Decide if using DC strength or should read and use AC strength
    if (strength <= 200) {
      // Use AC Dir
      dir = 0; strength = 0;
      cmdBuf[1] = 0x49; // Recycle rest of cmdBuf from the DC read operation
      cResp=6;
      fSuccess = I2CBytes(port, cmdBuf, cResp, respBuf);
      if (fSuccess) {
        dir = respBuf[0];
        // Sum the sensor elements to get strength
        if (dir > 0) for (i=1; i<=5; i++) strength += respBuf[i];
      }
    }
  }
}

///////////////////////////////////////////////////////////////////////////////

void println(string what, int num){
     ClearScreen();
     TextOut(10,LCD_LINE5,what);
     NumOut(10,LCD_LINE6,num);
}

void turnRight(){
     Off(OUT_BC);
     OnFwd(OUT_B,POWER);
     OnFwd(OUT_C,-POWER);
     return;
}

void turnLeft(){
     Off(OUT_BC);
     OnFwd(OUT_B,-POWER);
     OnFwd(OUT_C,POWER);
     return;
}

int iSeeBlack(int GREEN){
    if (Sensor(IN_2)<GREEN-5 || Sensor(IN_2) > GREEN+10){
       Off(OUT_ABC);
       return 0;
       }
    else
        return 1;
    }
    
void goBackBlack(){
     Off(OUT_ABC);
     OnFwd(OUT_BC,-OVERPOWER);
     Wait(320);
     Off(OUT_ABC);
     return;
}
