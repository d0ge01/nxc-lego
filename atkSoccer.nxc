
int ownGoal, currentCompass, relBearing, dir, pot, cal,dd;
mutex moveMutex;

void HTEnhancedIRSeekerV2(const byte  port, int &dir, int &strength);

void move(int a, int b) {
     Acquire(moveMutex);
     if ( a != 0 )
        OnFwd(OUT_B, a);
     if ( b != 0 )
         OnFwd(OUT_C, b);
     Wait(200);
     Release(moveMutex);
}

void println(string what, int num) {
     ClearScreen();
     TextOut(10,LCD_LINE5,what);
     NumOut(10,LCD_LINE6,num);
}

sub setSensorCompass (){
   SetSensorLowspeed(S3);
   TextOut(0,LCD_LINE1, "Point to goal" );
   TextOut(0,LCD_LINE3, "Press Orange " );
   TextOut(0,LCD_LINE4, "button" );
   until(ButtonPressed(BTN4, true));
   ownGoal=SensorHTCompass(S3);
   ClearScreen();
   TextOut(0,LCD_LINE3, "Setting course");
   Wait(100);
   }

task nowSensorCompass(){
   while(1) {
 //   ClearScreen();
      currentCompass=SensorHTCompass(S3);
      ownGoal = SensorHTCompass(S3);
 //   NumOut(10,LCD_LINE2,currentCompass);
      relBearing = currentCompass - ownGoal;
      if (relBearing < 0){
         relBearing=relBearing+360;
      }
 //   TextOut(10,LCD_LINE5,"Relative reading" );
  //  NumOut(10,LCD_LINE6,relBearing);
  //  TextOut(10, LCD_LINE7, "Current Target:");
  //  NumOut(10, LCD_LINE8, ownGoal);
   Wait(200);
   }
}


task moving() {
     while(true){
              HTEnhancedIRSeekerV2(S1, dir, pot);

              if ( currentCompass == -ownGoal ) {
                 move(-100, 100);
                 move(-100, 100);
                 move(-100, 100);
              }
              if ( Sensor(IN_1) > cal+10 ) {
                   move(70, 100);
              } else {
                if ( dir < 5 ) {
                   println("Vado a sinistra", 0);
                   move(40, 80);
                }
                if ( dir > 5 ) {
                   println("Vado a destra", 0);
                   move(80, 40);
                }
                if ( dir == 5 ) {
                   println("Vado a sinistra", 0);
                   move(50, 50);
                }
              }
     }
}

task main(){
   setSensorCompass();
   SetSensorLight(S2);
   cal = Sensor(S2);
   Precedes(moving,nowSensorCompass);
}

void HTEnhancedIRSeekerV2(const byte  port, int &dir, int &strength)
{
  int cResp;
  byte cmdBuf[] = {0x10, 0x43};   // Read DC signal strengths (skip the dir)
  byte respBuf[];                 // Response Buffer
  bool fSuccess;
  int i, iMax;
  long dcSigSum, dcStr;

  dir = 0;
  strength = 0;

  // Read DC mode
  cResp=6;
  fSuccess = I2CBytes(port, cmdBuf, cResp, respBuf);
  if (fSuccess) {
    // Find the max DC sig strength
    iMax = 0;
    for (i=1; i<5; i++) if (respBuf[i] > respBuf[iMax]) iMax = i;
    // Calc base DC direction value
    dir = iMax*2+1;
    // Set base dcStrength based on max signal and average
    dcSigSum = respBuf[iMax] + respBuf[5];
    // Check signal strength of neighboring sensor elements
    if ((iMax > 0) && (respBuf[iMax-1] > respBuf[iMax]/2)) {
        dir--;
        dcSigSum += respBuf[iMax-1];
    }
    if ((iMax < 4) && (respBuf[iMax+1] > respBuf[iMax]/2)) {
        dir++;
        dcSigSum += respBuf[iMax+1];
    }
    // Make DC strength compatible with AC strength. use: sqrt(dcSigSum*500)
    dcSigSum *= 500; dcStr = 1;
    repeat(10) dcStr = (dcSigSum/dcStr + dcStr) / 2;  // sqrt approx
    strength = dcStr;
    // Decide if using DC strength or should read and use AC strength
    if (strength <= 200) {
      // Use AC Dir
      dir = 0; strength = 0;
      cmdBuf[1] = 0x49; // Recycle rest of cmdBuf from the DC read operation
      cResp=6;
      fSuccess = I2CBytes(port, cmdBuf, cResp, respBuf);
      if (fSuccess) {
        dir = respBuf[0];
        // Sum the sensor elements to get strength
        if (dir > 0) for (i=1; i<=5; i++) strength += respBuf[i];
      }
    }
  }
}
