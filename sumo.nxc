/*
  Salvatore Criscione 2014-2015

  Lego nxt sumo , Primo software di prova...


  Il software deve girare su se stesso dopo una pausa di 5 secondi,

  Funziona in questo modo , praticamente dusando il sensore ultrarossi


  di default il robot gira da sokverso orario, quindi cerca di spingere fuori gli avversari

 */

#define MOTOR_DEX OUT_C
#define MOTOR_SIX OUT_B
#define MOTOR_AUX OUT_A

#define SENSOR_T    S3
#define SENSOR_U    S2
#define SENSOR_L    S1

#define S_SPIN_R    1
#define S_SPIN_L    2
#define S_SPIN      3
#define S_MOVE_F    4
#define S_MOVE_B    5


#define TS_LONG     40
#define TS_NEAR     15
#define TS_SPIN     -1

#define FAST        50
#define SLOW        50

int dd, hope_a, hope_b, S_LUCE;
unsigned int time;

mutex moveMutex;

int borders();
int sensors();

void move(int a, int b);
void print(int riga, string testo, int numero);
void inizializza();
bool checkOverload();
void neon();

task ControlLine() {
     while(1) {
              if ( Sensor(SENSOR_L) &gt; S_LUCE ) {
                 // Forza al istante l'acquisizione dei motori
                 Acquire(moveMutex);
                 move(-FAST, -FAST);
                 Wait(1000);
                 Release(moveMutex);
              }
              Wait(100);
     }
}

task Moving() {
     Wait(4800);
     OnFwd(MOTOR_AUX, 80);
     Wait(200);
     Off(MOTOR_AUX);
     while(1) {
     switch(dd) {
        case S_SPIN_R:
           Acquire(moveMutex);
           move(-SLOW, SLOW);
           Release(moveMutex);
           print(1, "NIENTE", 0);
           break;
        case S_MOVE_F:
           Acquire(moveMutex);
           move(FAST, FAST);
           Release(moveMutex);
           print(1, "MI AVVICINO", 0);
           break;
        case S_SPIN:
           Acquire(moveMutex);
           move(FAST, -FAST);
           Wait(1000);
           Release(moveMutex);

           print(1, "VICINO GIRO :D", 0);
           break;
        case S_SPIN_L:
           Acquire(moveMutex);
           move(-FAST, FAST);
           Release(moveMutex);
           print(1, "INVERTO GIRO", 0);
           break;
        default:
           Acquire(moveMutex);
           move(-SLOW, SLOW);
           Release(moveMutex);
           print(1, ":( NIENTE DI NIENTE", 0);
           break; // useless :(:/(
     }
     }

}

task Sensors() {
    // 0 nothing found
    // 1 faraway
    // 2 front near
    // -1 border :(:(:(:(

    while(1) {

             if ( SENSOR_T == 1 ) {
                dd = S_SPIN;
             }else {
                   if ( SENSOR_3 == 0 )
                      if ( checkOverload() ) {
                         dd = S_SPIN_L;
                      } else {
                         dd = S_SPIN;
                      }
                   if ( SensorUS(S2) &lt; TS_LONG )
                      if ( SensorUS(S2) &lt; TS_NEAR )
                         dd = S_SPIN;
                      else
                         dd = S_MOVE_F;
                   else
                      dd = S_SPIN_R;
             }
    }
}

task main() {
     neon();
     inizializza();
     S_LUCE = Sensor(SENSOR_L) + 15;

     Precedes(Sensors, Moving, ControlLine);
}

void move(int a, int b) {
     OnFwd(MOTOR_SIX, a);
     OnFwd(MOTOR_DEX, b);
     Wait(200);
}

void print(int riga, string testo, int numero) {
     int lnum=(8-riga)*8;
     ClearLine(lnum);
     TextOut(0, lnum, testo);
     if ( numero ) NumOut(6*strlen(testo), lnum, numero);
}


void inizializza() {
     SetSensorUltrasonic(SENSOR_U);
     SetSensorLight(SENSOR_L);
}

bool checkOverload() {
     hope_a = MotorRotationCount(MOTOR_DEX);
     Wait(100);
     hope_b = MotorRotationCount(MOTOR_DEX);
     if ( hope_b &gt;= hope_a-30 || hope_b &lt; hope_a+30 )
        return true;
     else
        return false;
}


void neon() {
     for ( int i = 0 ; i &lt; 5; i++ ) {
         SetSensorType(SENSOR_L, IN_TYPE_LIGHT_ACTIVE);
         Wait(480);
         SetSensorType(SENSOR_L, IN_TYPE_LIGHT_INACTIVE);
         Wait(480);
     }
     SetSensorType(SENSOR_L, IN_TYPE_LIGHT_ACTIVE);
}
